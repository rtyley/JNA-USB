package libusbone;
/**
 * \ingroup asyncio<br>
 * The generic USB transfer structure. The user populates this structure and<br>
 * then submits it in order to request a transfer. After the transfer has<br>
 * completed, the library populates the transfer with the results and passes<br>
 * it back to the user.<br>
 * <i>native declaration : /usr/include/limits.h:682</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a>, <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public class libusb_transfer extends com.sun.jna.Structure {
	/**
	 * Handle of the device that this transfer will be submitted to<br>
	 * C type : libusb_device_handle*
	 */
	public libusbone.LibusboneLibrary.libusb_device_handle dev_handle;
	/// A bitwise OR combination of \ref libusb_transfer_flags.
	public byte flags;
	/// Address of the endpoint where this transfer will be sent.
	public byte endpoint;
	/// Type of the endpoint from \ref libusb_transfer_type
	public byte type;
	/**
	 * Timeout for this transfer in millseconds. A value of 0 indicates no<br>
	 * timeout.
	 */
	public int timeout;
	/**
	 * The status of the transfer. Read-only, and only for use within<br>
	 * transfer callback function.<br>
	 * * If this is an isochronous transfer, this field may read COMPLETED even<br>
	 * if there were errors in the frames. Use the<br>
	 * \ref libusb_iso_packet_descriptor::status "status" field in each packet<br>
	 * to determine if errors occurred.<br>
	 * @see libusb_transfer_status<br>
	 * C type : libusb_transfer_status
	 */
	public int status;
	/// Length of the data buffer
	public int length;
	/**
	 * Actual length of data that was transferred. Read-only, and only for<br>
	 * use within transfer callback function. Not valid for isochronous<br>
	 * endpoint transfers.
	 */
	public int actual_length;
	/**
	 * Callback function. This will be invoked when the transfer completes,<br>
	 * fails, or is cancelled.<br>
	 * C type : libusb_transfer_cb_fn
	 */
	public libusbone.LibusboneLibrary.libusb_transfer_cb_fn callback;
	/**
	 * User context data to pass to the callback function.<br>
	 * C type : void*
	 */
	public com.sun.jna.Pointer user_data;
	/**
	 * Data buffer<br>
	 * C type : unsigned char*
	 */
	public com.sun.jna.Pointer buffer;
	/**
	 * Number of isochronous packets. Only used for I/O with isochronous<br>
	 * endpoints.
	 */
	public int num_iso_packets;
	/**
	 * Isochronous packet descriptors, for isochronous transfers only.<br>
	 * C type : libusb_iso_packet_descriptor[0]
	 */
	public libusbone.libusb_iso_packet_descriptor[] iso_packet_desc = new libusbone.libusb_iso_packet_descriptor[(0)];
	public libusb_transfer() {
		super();
	}
	protected ByReference newByReference() {
		ByReference s = new ByReference();
		s.useMemory(getPointer());
		write();
		s.read();
		return s;
	}
	protected ByValue newByValue() {
		ByValue s = new ByValue();
		s.useMemory(getPointer());
		write();
		s.read();
		return s;
	}
	protected libusb_transfer newInstance() {
		libusb_transfer s = new libusb_transfer();
		s.useMemory(getPointer());
		write();
		s.read();
		return s;
	}
	public static class ByReference extends libusb_transfer implements com.sun.jna.Structure.ByReference {}
	public static class ByValue extends libusb_transfer implements com.sun.jna.Structure.ByValue {}
}
